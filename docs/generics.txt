## Generics

There are two forms of generic types, universally quantified types and
existentially quantified types.

### Universal types

Universal types allow parameterized algebraic data types and generic functions.

#### Parameterized algebraic data types

Arrays are the most basic parameterized algebraic data type, whose parameters
are the data type of the members and the number of members.

#### Generic functions

```
reduce[A, B, USize c]: (
    (arr: Arr[A, c], init: B, fn: (A, B) => B) -> B
)[A, B, const USize c] := \|{
    let acc = init;
    loop x from arr {
        acc = fn(x, acc);
    }
    return acc;
}
```

### Existential types

Existential types allow the hiding of type information in algebraic data types.
When supplied a value of an existential type, the consumer does not need to know
and cannot know the specific type that is being existentially quantified.

#### Abstract types

Abstract types reflect how a type interacts with other types, regardless of
the underlying data. Such interactions are defined by methods, function types
that take the behavioral type as the first argument.

```
(
    self: ?T,
    get_size: (?T) -> (U32),
    get_name: (?T) -> Arr[U8, 10],
)[?T]

// a@b(c) is equiv to a.b(a.self, c)
```

### Concrete types

Concrete types reflect the implementation of an abstract type as an underlying
structural type. See the following example for concrete types `RectangularPrism`
and `Cube`:

```
SomeStruct := (
    x: U32,
    y: U32,
    z: U32,
);

HasVolume[?T] := (
    self: ?T,
    get_volume: (?T) -> (U32),
)[?T];

RectangularPrism := HasVolume[SomeStruct];

_cast: (self: SomeStruct) -> RectangularPrism := \|{
    return (
        self = self,
        get_volume = \|{
	    return self.x * self.y * self.z;
	}
    );
};

Cube := HasVolume[U32];

_cast: (self: U32) -> Cube := \|{
    return (
        self = self,
        get_volume = \|{
            return self * self * self;
        }
    );
};

print_volume: (x: HasVolume, p: Printer) -> () {
    p@print(x@get_volume());
}

main: (p: Printer) -> () {
    10.print_volume(p); // prints 1000
    (x = 1, y = 2, z = 3).print_volume(p) // prints 6
}
```


examples:

```
map_inplace[USize len]: ((arr: &mut Arr[?A, len], fn: ?A => ?A) -> ())[?A, USize len] := {
    loop j from range(len) {
        arr[j] = fn arr[j];
    }
}
```
